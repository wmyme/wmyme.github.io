<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    Gridea
</title>
<link rel="shortcut icon" href="https://wmyme.github.io//favicon.ico?v=1628740403686">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://wmyme.github.io//styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://wmyme.github.io//media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://wmyme.github.io/">
                <img class="avatar" src="https://wmyme.github.io//images/avatar.png?v=1628740403686" alt="">
            </a>
            <div class="site-title">
                <h1>
                    Gridea
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="https://wmyme.github.io/categories" class="menu">
                                    分类
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://wmyme.github.io/post/js-shi-xian-wang-zhan-yun-xing-shi-jian-tong-ji/">
                        js实现网站运行时间统计
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-08-12</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            &amp;lt;span id=&amp;quot;sitetime&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;script language=javascript&amp;gt;
    function siteTime(){
        window.setTimeout(&amp;quot;siteTime()&amp;quot;, 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth()+1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        var t1 = Date.UTC(2021,8,11,00,00,00); //北京时间2016-12-1 00:00:00
        var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
        var diff = t2-t1;
        var diffYears = Math.floor(diff/years);
        var diffDays = Math.floor((diff/days)-diffYears*365);
        var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
        var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
        var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
        document.getElementById(&amp;quot;sitetime&amp;quot;).innerHTML=&amp;quot; 已运行&amp;quot;+diffYears+&amp;quot;年 &amp;quot;+diffDays+&amp;quot; 天 &amp;quot;+diffHours+&amp;quot; 小时 &amp;quot;+diffMinutes+&amp;quot; 分钟 &amp;quot;+diffSeconds+&amp;quot; 秒&amp;quot;;
    }
    siteTime();
&amp;lt;/script&amp;gt;


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://wmyme.github.io/post/js-shi-xian-wang-zhan-yun-xing-shi-jian-tong-ji/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://wmyme.github.io/post/vue-jiao-shou-jia/">
                        Vue脚手架
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-08-12</time>
                    
                        <a href="https://wmyme.github.io/tag/I2_zt_SbB/" class="post-tag i-tag
                            i-tag-">
            #vue
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            脚手架文件结构
├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件

关于不同版本的Vue

vue.js与vue.runtime.xxx.js的区别：

vue.js是完整版的Vue，包含：核心功能 + 模板解析器。
vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。


因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。

vue.config.js配置文件

使用vue inspect &amp;gt; output.js可以查看到Vue脚手架的默认配置。
使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh

ref属性

被用来给元素或子组件注册引用信息（id的替代者）
应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）
使用方式：

打标识：&amp;lt;h1 ref=&amp;quot;xxx&amp;quot;&amp;gt;.....&amp;lt;/h1&amp;gt; 或 &amp;lt;School ref=&amp;quot;xxx&amp;quot;&amp;gt;&amp;lt;/School&amp;gt;
获取：this.$refs.xxx



props配置项


功能：让组件接收外部传过来的数据


传递数据：&amp;lt;Demo name=&amp;quot;xxx&amp;quot;/&amp;gt;


接收数据：


第一种方式（只接收）：props:[&#39;name&#39;]


第二种方式（限制类型）：props:{name:String}


第三种方式（限制类型、限制必要性、指定默认值）：
props:{
	name:{
	type:String, //类型
	required:true, //必要性
	default:&#39;老王&#39; //默认值
	}
}




备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。



mixin(混入)


功能：可以把多个组件共用的配置提取成一个混入对象


使用方式：
第一步定义混合：
{
    data(){....},
    methods:{....}
    ....
}

第二步使用混入：
​	全局混入：Vue.mixin(xxx)
​	局部混入：mixins:[&#39;xxx&#39;]


插件


功能：用于增强Vue


本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。


定义插件：
对象.install = function (Vue, options) {
    // 1. 添加全局过滤器
    Vue.filter(....)

    // 2. 添加全局指令
    Vue.directive(....)


    // 3. 配置全局混入(合)
    Vue.mixin(....)

    // 4. 添加实例方法
    Vue.prototype.$myMethod = function () {...}
    Vue.prototype.$myProperty = xxxx
}



使用插件：Vue.use()


scoped样式

作用：让样式在局部生效，防止冲突。
写法：&amp;lt;style scoped&amp;gt;


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://wmyme.github.io/post/vue-jiao-shou-jia/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://wmyme.github.io/post/http/">
                        Http
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2021-08-11</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            概念
​	Hyper Text Transfer Protocol 超文本传输协议


传输协议：定义了，客户端和服务器端通信时，发送数据的格式


特点：

基于TCP/IP的高级协议
默认端口号:80
基于请求/响应模型的:一次请求对应一次响应
无状态的：每次请求之间相互独立，不能交互数据



历史版本：

1.0：每一次请求响应都会建立新的连接
1.1：复用连接



请求消息数据格式
1.请求行
请求方式 请求url 请求协议/版本
GET /login.html	HTTP/1.1
请求方式：
HTTP协议有7中请求方式，常用的有2种


GET：
​	1.请求参数在请求行中，在url后。
​	2.请求的url长度有限制的
​	3.不太安全


POST：
​	1.请求参数在请求体中
​	2.请求的url长度没有限制的
​	3.相对安全


2.请求头
客户端浏览器告诉服务器一些信息
请求头名称: 请求头值


常见的请求头：

User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息


可以在服务器端获取该头的信息，解决浏览器的兼容性问题


Referer：http://localhost/login.html

告诉服务器，我(当前请求)从哪里来？
作用：
1. 防盗链：
2. 统计工作：





3.请求空行
空行，就是用于分割POST请求的请求头，和请求体的。
4.请求体(正文)
​		封装POST请求消息的请求参数的
5.字符串格式
​	POST /login.html	HTTP/1.1
​	Host: localhost
​	User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0
​	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8
​	Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
​	Accept-Encoding: gzip, deflate
​	Referer: http://localhost/login.html
​	Connection: keep-alive
​	Upgrade-Insecure-Requests: 1
​	username=zhangsan
响应消息数据格式
Request
request和response的原理

request和response对象是由服务器创建的。我们来使用它们
request对象是来获取请求消息，response对象是来设置响应消息

request对象继承体系结构
ServletRequest		--	接口
|	继承
HttpServletRequest	-- 接口
|	实现
org.apache.catalina.connector.RequestFacade 类(tomcat)
request功能

获取请求消息数据


获取请求行数据

GET /day14/demo1?name=zhangsan HTTP/1.1
方法：


获取请求方式 ：GET

String getMethod()



(*)获取虚拟目录：/day14

String getContextPath()



获取Servlet路径: /demo1

String getServletPath()



获取get方式请求参数：name=zhangsan

String getQueryString()



(*)获取请求URI：/day14/demo1


String getRequestURI():		/day14/demo1


StringBuffer getRequestURL()  :http://localhost/day14/demo1


URL:统一资源定位符 ： http://localhost/day14/demo1	中华人民共和国


URI：统一资源标识符 : /day14/demo1					共和国




获取协议及版本：HTTP/1.1

String getProtocol()



获取客户机的IP地址：

String getRemoteAddr()







获取请求头数据

方法：

(*)String getHeader(String name):通过请求头的名称获取请求头的值
Enumeration getHeaderNames():获取所有的请求头名称





获取请求体数据:

请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数
步骤：


获取流对象

BufferedReader getReader()：获取字符输入流，只能操作字符数据
ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据

在文件上传知识点后讲解





再从流对象中拿数据








​
其他功能
​		1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数
​				1. String getParameter(String name):根据参数名称获取参数值    username=zs&amp;amp;password=123
​				2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;amp;hobby=game
​				3. Enumeration getParameterNames():获取所有请求的参数名称
​				4. Map&amp;lt;String,String[]&amp;gt; getParameterMap():获取所有参数的map集合
​	
​			* 中文乱码问题：
​				* get方式：tomcat 8 已经将get方式乱码问题解决了
​				* post方式：会乱码
​					* 解决：在获取参数前，设置request的编码request.setCharacterEncoding(&amp;quot;utf-8&amp;quot;);
​			2. 请求转发：一种在服务器内部的资源跳转方式
​				1. 步骤：
​					1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)
​					2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)
​	
​			2. 特点：
​				1. 浏览器地址栏路径不发生变化
​				2. 只能转发到当前服务器内部资源中。
​				3. 转发是一次请求

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://wmyme.github.io/post/http/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://wmyme.github.io/post/hello-gridea/">
                        Webpack
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-12-12</time>
                    
                        <a href="https://wmyme.github.io/tag/iJ2u2cx9E/" class="post-tag i-tag
                            i-tag-primary">
            #Gridea
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
健康快乐每一天
Webpack入门-学习总结
 写于2020-07-16
所有的代码在github
一、Webpack 简介
1.1 webpack 是什么
webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。
在webpack 看来, 前端的所有资源文件(js/json/css/img/less/...)都会作为模块处理。
它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。
1.2 webpack 五个核心概念
1.2.1 Entry
入口(Entry)：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。
1.2.2 Output
输出(Output)：指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。
1.2.3 Loader
Loader：让 webpack 能够去处理那些非 JS 的文件，比如样式文件、图片文件(webpack 自身只理解
JS)
1.2.4 Plugins
插件(Plugins)：可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，
一直到重新定义环境中的变量等。
1.2.5 Mode
模式(Mode)：指示 webpack 使用相应模式的配置。



选项
描述
特点




development
会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。
能让代码本地调试运行的环境


production
会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。
能让代码优化上线运行的环境



二、Webpack 初体验
2.1 初始化配置


初始化 package.json：npm init


下载安装webpack：(webpack4以上的版本需要全局/本地都安装webpack-cli)
全局安装：cnpm i webpack webpack-cli -g
本地安装：cnpm i webpack webpack-cli -D


2.2 编译打包应用
创建 src 下的 js 等文件后，不需要配置 webpack.config.js 文件，在命令行就可以编译打包。
指令：


开发环境：webpack ./src/index.js -o ./build/built.js --mode=development
webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js 整体打包环境，是开发环境


生产环境：webpack ./src/index.js -o ./build/built.js --mode=production
webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js 整体打包环境，是生产环境


结论：

webpack 本身能处理 js/json 资源，不能处理 css/img 等其他资源
生产环境和开发环境将 ES6 模块化编译成浏览器能识别的模块化，但是不能处理 ES6 的基本语法转化为 ES5（需要借助 loader）
生产环境比开发环境多一个压缩 js 代码

三、Webpack 开发环境的基本配置
webpack.config.js 是 webpack 的配置文件。
作用: 指示 webpack 干哪些活（当你运行 webpack 指令时，会加载里面的配置）
所有构建工具都是基于 nodejs 平台运行的，模块化默认采用 commonjs。
开发环境配置主要是为了能让代码运行。主要考虑以下几个方面：

打包样式资源
打包 html 资源
打包图片资源
打包其他资源
devServer

下面是一个简单的开发环境webpack.confg.js配置文件
// resolve用来拼接绝对路径的方法
const { resolve } = require(&#39;path&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;) // 引用plugin

module.exports = {
  // webpack配置
  entry: &#39;./src/js/index.js&#39;, // 入口起点
  output: {
    // 输出
    // 输出文件名
    filename: &#39;js/build.js&#39;,
    // __dirname是nodejs的变量，代表当前文件的目录绝对路径
    path: resolve(__dirname, &#39;build&#39;), // 输出路径，所有资源打包都会输出到这个文件夹下
  },
  // loader配置
  module: {
    rules: [
      // 详细的loader配置
      // 不同文件必须配置不同loader处理
      {
        // 匹配哪些文件
        test: /\.less$/,
        // 使用哪些loader进行处理
        use: [
          // use数组中loader执行顺序：从右到左，从下到上，依次执行(先执行css-loader)
          // style-loader：创建style标签，将js中的样式资源插入进去，添加到head中生效
          &#39;style-loader&#39;,
          // css-loader：将css文件变成commonjs模块加载到js中，里面内容是样式字符串
          &#39;css-loader&#39;,
          // less-loader：将less文件编译成css文件，需要下载less-loader和less
          &#39;less-loader&#39;
        ],
      },
      {
        test: /\.css$/,
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;],
      },
      {
        // url-loader：处理图片资源，问题：默认处理不了html中的img图片
        test: /\.(jpg|png|gif)$/,
        // 需要下载 url-loader file-loader
        loader: &#39;url-loader&#39;,
        options: {
          // 图片大小小于8kb，就会被base64处理，优点：减少请求数量（减轻服务器压力），缺点：图片体积会更大（文件请求速度更慢）
          // base64在客户端本地解码所以会减少服务器压力，如果图片过大还采用base64编码会导致cpu调用率上升，网页加载时变卡
          limit: 8 * 1024,
          // 给图片重命名，[hash:10]：取图片的hash的前10位，[ext]：取文件原来扩展名
          name: &#39;[hash:10].[ext]&#39;,
          // 问题：因为url-loader默认使用es6模块化解析，而html-loader引入图片是conmonjs，解析时会出问题：[object Module]
          // 解决：关闭url-loader的es6模块化，使用commonjs解析
          esModule: false,
          outputPath: &#39;imgs&#39;,
        },
      },
      {
        test: /\.html$/,
        // 处理html文件的img图片（负责引入img，从而能被url-loader进行处理）
        loader: &#39;html-loader&#39;,
      },
      // 打包其他资源(除了html/js/css资源以外的资源)
      {
        // 排除html|js|css|less|jpg|png|gif文件
        exclude: /\.(html|js|css|less|jpg|png|gif)/,
        // file-loader：处理其他文件
        loader: &#39;file-loader&#39;,
        options: {
          name: &#39;[hash:10].[ext]&#39;,
          outputPath: &#39;media&#39;,
        },
      },
    ],
  },
  // plugin的配置
  plugins: [
    // html-webpack-plugin：默认会创建一个空的html文件，自动引入打包输出的所有资源（JS/CSS）
    // 需要有结构的HTML文件可以加一个template
    new HtmlWebpackPlugin({
      // 复制这个./src/index.html文件，并自动引入打包输出的所有资源（JS/CSS）
      template: &#39;./src/index.html&#39;,
    }),
  ],
  // 模式
  mode: &#39;development&#39;, // 开发模式
  // 开发服务器 devServer：用来自动化，不用每次修改后都重新输入webpack打包一遍（自动编译，自动打开浏览器，自动刷新浏览器）
  // 特点：只会在内存中编译打包，不会有任何输出（不会像之前那样在外面看到打包输出的build包，而是在内存中，关闭后会自动删除）
  // 启动devServer指令为：npx webpack-dev-server
  devServer: {
    // 项目构建后路径
    contentBase: resolve(__dirname, &#39;build&#39;),
    // 启动gzip压缩
    compress: true,
    // 端口号
    port: 3000,
    // 自动打开浏览器
    open: true,
  },
}

其中，大部分配置都在注释中给出解释。


运行项目的两个指令：
webpack 会将打包结果输出出去（build文件夹）
npx webpack-dev-server 只会在内存中编译打包，没有输出


loader 和 plugin 的不同：（plugin 一定要先引入才能使用）
loader：1. 下载 2. 使用（配置 loader）
plugins：1.下载 2. 引入 3. 使用


四、Webpack 生产环境的基本配置
而生产环境的配置需要考虑以下几个方面：

提取 css 成单独文件
css 兼容性处理
压缩 css
js 语法检查
js 兼容性处理
js 压缩
html 压缩

下面是一个基本的生产环境下的webpack.config.js配置
const { resolve } = require(&#39;path&#39;)
const MiniCssExtractorPlugin = require(&#39;mini-css-extract-plugin&#39;)
const OptimiziCssAssetsWebpackPlugin = require(&#39;optimizi-css-assets-webpack-plugin&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

// 定义node.js的环境变量，决定使用browserslist的哪个环境
process.env.NODE_ENV = &#39;production&#39;

// 复用loader的写法
const commonCssLoader = [
  // 这个loader取代style-loader。作用：提取js中的css成单独文件然后通过link加载
  MiniCssExtractPlugin.loader,
  // css-loader：将css文件整合到js文件中
  // 经过css-loader处理后，样式文件是在js文件中的
  // 问题：1.js文件体积会很大2.需要先加载js再动态创建style标签，样式渲染速度就慢，会出现闪屏现象
  // 解决：用MiniCssExtractPlugin.loader替代style-loader
  &#39;css-loader&#39;,
  /*
    postcss-loader：css兼容性处理：postcss --&amp;gt; 需要安装：postcss-loader postcss-preset-env
    postcss需要通过package.json中browserslist里面的配置加载指定的css兼容性样式
    在package.json中定义browserslist：
    &amp;quot;browserslist&amp;quot;: {
      // 开发环境 --&amp;gt; 设置node环境变量：process.env.NODE_ENV = development
      &amp;quot;development&amp;quot;: [ // 只需要可以运行即可
        &amp;quot;last 1 chrome version&amp;quot;,
        &amp;quot;last 1 firefox version&amp;quot;,
        &amp;quot;last 1 safari version&amp;quot;
      ],
      // 生产环境。默认是生产环境
      &amp;quot;production&amp;quot;: [ // 需要满足绝大多数浏览器的兼容
        &amp;quot;&amp;gt;0.2%&amp;quot;,
        &amp;quot;not dead&amp;quot;,
        &amp;quot;not op_mini all&amp;quot;
      ]
    },
  */
  {
    loader: &#39;postcss-loader&#39;,
    options: {
      ident: &#39;postcss&#39;, // 基本写法
      plugins: () =&amp;gt; [
        // postcss的插件
        require(&#39;postcss-preset-env&#39;)(),
      ],
    },
  },
]

module.exports = {
  entry: &#39;./src/js/index.js&#39;,
  output: {
    filename: &#39;js/built.js&#39;,
    path: resolve(__dirname, &#39;build&#39;),
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [...commonCssLoader],
      },
      {
        test: /\.less$/,
        use: [...commonCssLoader, &#39;less-loader&#39;],
      },
      /*
        正常来讲，一个文件只能被一个loader处理
        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序
        先执行eslint再执行babel（用enforce）
      */
      {
        /*
          js的语法检查： 需要下载 eslint-loader eslint
          注意：只检查自己写的源代码，第三方的库是不用检查的
          airbnb(一个流行的js风格) --&amp;gt; 需要下载 eslint-config-airbnb-base eslint-plugin-import
          设置检查规则：
            package.json中eslintConfig中设置
              &amp;quot;eslintConfig&amp;quot;: {
                &amp;quot;extends&amp;quot;: &amp;quot;airbnb-base&amp;quot;， // 继承airbnb的风格规范
                &amp;quot;env&amp;quot;: {
                  &amp;quot;browser&amp;quot;: true // 可以使用浏览器中的全局变量(使用window不会报错)
                }
              }
        */
        test: /\.js$/,
        exclude: /node_modules/, // 忽略node_modules
        enforce: &#39;pre&#39;, // 优先执行
        loader: &#39;eslint-loader&#39;,
        options: {
          // 自动修复
          fix: true,
        },
      },
      /*
        js兼容性处理：需要下载 babel-loader @babel/core
          1. 基本js兼容性处理 --&amp;gt; @babel/preset-env
            问题：只能转换基本语法，如promise高级语法不能转换
          2. 全部js兼容性处理 --&amp;gt; @babel/polyfill
            问题：只要解决部分兼容性问题，但是将所有兼容性代码全部引入，体积太大了
          3. 需要做兼容性处理的就做：按需加载  --&amp;gt; core-js
      */
      {
        // 第三种方式：按需加载
        test: /\.js$/,
        exclude: /node_modules/,
        loader: &#39;babel-loader&#39;,
        options: {
          // 预设：指示babel做怎样的兼容性处理
          presets: [
            &#39;@babel/preset-env&#39;, // 基本预设
            {
              useBuiltIns: &#39;usage&#39;, //按需加载
              corejs: { version: 3 }, // 指定core-js版本
              targets: { // 指定兼容到什么版本的浏览器
                chrome: &#39;60&#39;,
                firefox: &#39;50&#39;,
                ie: &#39;9&#39;,
                safari: &#39;10&#39;,
                edge: &#39;17&#39;
              },
            },
          ],
        },
      },
      {
        // 图片处理
        test: /\.(jpg|png|gif)/,
        loader: &#39;url-loader&#39;,
        options: {
          limit: 8 * 1024,
          name: &#39;[hash:10].[ext]&#39;,
          outputPath: &#39;imgs&#39;,
          esModule: false, // 关闭url-loader默认使用的es6模块化解析
        },
      },
      // html中的图片处理
      {
        test: /\.html$/,
        loader: &#39;html-loader&#39;,
      },
      // 处理其他文件
      {
        exclude: /\.(js|css|less|html|jpg|png|gif)/,
        loader: &#39;file-loader&#39;,
        options: {
          outputPath: &#39;media&#39;,
        },
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      // 对输出的css文件进行重命名
      filename: &#39;css/built.css&#39;,
    }),
    // 压缩css
    new OptimiziCssAssetsWebpackPlugin(),
    // HtmlWebpackPlugin：html文件的打包和压缩处理
    // 通过这个插件会自动将单独打包的样式文件通过link标签引入
    new HtmlWebpackPlugin({
      template: &#39;./src/index.html&#39;,
      // 压缩html代码
      minify: {
        // 移除空格
        collapseWhitespace: true,
        // 移除注释
        removeComments: true,
      },
    }),
  ],
  // 生产环境下会自动压缩js代码
  mode: &#39;production&#39;,
}

五、Webpack 优化配置
5.1 开发环境性能优化
5.1.1 HMR（模块热替换）
HMR: hot module replacement 热模块替换 / 模块热替换
作用：一个模块发生变化，只会重新打包构建这一个模块（而不是打包所有模块） ，极大提升构建速度
代码：只需要在 devServer 中设置 hot 为 true，就会自动开启HMR功能（只能在开发模式下使用）
devServer: {
  contentBase: resolve(__dirname, &#39;build&#39;),
  compress: true,
  port: 3000,
  open: true,
  // 开启HMR功能
  // 当修改了webpack配置，新配置要想生效，必须重启webpack服务
  hot: true
}

每种文件实现热模块替换的情况：


样式文件：可以使用HMR功能，因为开发环境下使用的 style-loader 内部默认实现了热模块替换功能


js 文件：默认不能使用HMR功能（修改一个 js 模块所有 js 模块都会刷新）
--&amp;gt; 实现 HMR 需要修改 js 代码（添加支持 HMR 功能的代码）
// 绑定
if (module.hot) {
  // 一旦 module.hot 为true，说明开启了HMR功能。 --&amp;gt; 让HMR功能代码生效
  module.hot.accept(&#39;./print.js&#39;, function() {
    // 方法会监听 print.js 文件的变化，一旦发生变化，只有这个模块会重新打包构建，其他模块不会。
    // 会执行后面的回调函数
    print();
  });
}

注意：HMR 功能对 js 的处理，只能处理非入口 js 文件的其他文件。


html 文件: 默认不能使用 HMR 功能（html 不用做 HMR 功能，因为只有一个 html 文件，不需要再优化）
使用 HMR 会导致问题：html 文件不能热更新了（不会自动打包构建）
解决：修改 entry 入口，将 html 文件引入（这样 html 修改整体刷新）
entry: [&#39;./src/js/index.js&#39;, &#39;./src/index.html&#39;]



5.1.2 source-map
source-map：一种提供源代码到构建后代码的映射的技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）
参数：[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map
代码：
devtool: &#39;eval-source-map&#39;

可选方案：[生成source-map的位置|给出的错误代码信息]

source-map：外部，错误代码准确信息 和 源代码的错误位置
inline-source-map：内联，只生成一个内联 source-map，错误代码准确信息 和 源代码的错误位置
hidden-source-map：外部，错误代码错误原因，但是没有错误位置（为了隐藏源代码），不能追踪源代码错误，只能提示到构建后代码的错误位置
eval-source-map：内联，每一个文件都生成对应的 source-map，都在 eval 中，错误代码准确信息 和 源代码的错误位
nosources-source-map：外部，错误代码准确信息，但是没有任何源代码信息（为了隐藏源代码）
cheap-source-map：外部，错误代码准确信息 和 源代码的错误位置，只能把错误精确到整行，忽略列
cheap-module-source-map：外部，错误代码准确信息 和 源代码的错误位置，module 会加入 loader 的 source-map

内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快
开发/生产环境可做的选择：
开发环境：需要考虑速度快，调试更友好

速度快( eval &amp;gt; inline &amp;gt; cheap &amp;gt;... )

eval-cheap-souce-map
eval-source-map


调试更友好

souce-map
cheap-module-souce-map
cheap-souce-map



最终得出最好的两种方案 --&amp;gt; eval-source-map（完整度高，内联速度快） / eval-cheap-module-souce-map（错误提示忽略列但是包含其他信息，内联速度快）
生产环境：需要考虑源代码要不要隐藏，调试要不要更友好

内联会让代码体积变大，所以在生产环境不用内联
隐藏源代码

nosources-source-map 全部隐藏
hidden-source-map 只隐藏源代码，会提示构建后代码错误信息



最终得出最好的两种方案 --&amp;gt; source-map（最完整） / cheap-module-souce-map（错误提示一整行忽略列）
5.2 生产环境性能优化
5.2.1 优化打包构建速度
5.2.1.1 oneOf
oneOf：匹配到 loader 后就不再向后进行匹配，优化生产环境的打包构建速度
代码：
module: {
  rules: [
    {
      // js 语法检查
      test: /\.js$/,
      exclude: /node_modules/,
      // 优先执行
      enforce: &#39;pre&#39;,
      loader: &#39;eslint-loader&#39;,
      options: {
        fix: true
      }
    },
    {
      // oneOf 优化生产环境的打包构建速度
      // 以下loader只会匹配一个（匹配到了后就不会再往下匹配了）
      // 注意：不能有两个配置处理同一种类型文件（所以把eslint-loader提取出去放外面）
      oneOf: [
        {
          test: /\.css$/,
          use: [...commonCssLoader]
        },
        {
          test: /\.less$/,
          use: [...commonCssLoader, &#39;less-loader&#39;]
        },
        {
          // js 兼容性处理
          test: /\.js$/,
          exclude: /node_modules/,
          loader: &#39;babel-loader&#39;,
          options: {
            presets: [
              [
                &#39;@babel/preset-env&#39;,
                {
                  useBuiltIns: &#39;usage&#39;,
                  corejs: {version: 3},
                  targets: {
                    chrome: &#39;60&#39;,
                    firefox: &#39;50&#39;
                  }
                }
              ]
            ]
          }
        },
        {
          test: /\.(jpg|png|gif)/,
          loader: &#39;url-loader&#39;,
          options: {
            limit: 8 * 1024,
            name: &#39;[hash:10].[ext]&#39;,
            outputPath: &#39;imgs&#39;,
            esModule: false
          }
        },
        {
          test: /\.html$/,
          loader: &#39;html-loader&#39;
        },
        {
          exclude: /\.(js|css|less|html|jpg|png|gif)/,
          loader: &#39;file-loader&#39;,
          options: {
            outputPath: &#39;media&#39;
          }
        }
      ]
    }
  ]
},

5.2.1.2 babel 缓存
babel 缓存：类似 HMR，将 babel 处理后的资源缓存起来（哪里的 js 改变就更新哪里，其他 js 还是用之前缓存的资源），让第二次打包构建速度更快
代码：
{
  test: /\.js$/,
  exclude: /node_modules/,
  loader: &#39;babel-loader&#39;,
  options: {
    presets: [
      [
        &#39;@babel/preset-env&#39;,
        {
          useBuiltIns: &#39;usage&#39;,
          corejs: { version: 3 },
          targets: {
            chrome: &#39;60&#39;,
            firefox: &#39;50&#39;
          }
        }
      ]
    ],
    // 开启babel缓存
    // 第二次构建时，会读取之前的缓存
    cacheDirectory: true
  }
},

文件资源缓存
文件名不变，就不会重新请求，而是再次用之前缓存的资源
1.hash: 每次 wepack 打包时会生成一个唯一的 hash 值。
问题：重新打包，所有文件的 hsah 值都改变，会导致所有缓存失效。（可能只改动了一个文件）
2.chunkhash：根据 chunk 生成的 hash 值。来源于同一个 chunk的 hash 值一样
问题：js 和 css 来自同一个chunk，hash 值是一样的（因为 css-loader 会将 css 文件加载到 js 中，所以同属于一个chunk）
3.contenthash: 根据文件的内容生成 hash 值。不同文件 hash 值一定不一样(文件内容修改，文件名里的 hash 才会改变)
修改 css 文件内容，打包后的 css 文件名 hash 值就改变，而 js 文件没有改变 hash 值就不变，这样 css 和 js 缓存就会分开判断要不要重新请求资源 --&amp;gt; 让代码上线运行缓存更好使用
5.2.1.3 多进程打包
多进程打包：某个任务消耗时间较长会卡顿，多进程可以同一时间干多件事，效率更高。
优点是提升打包速度，缺点是每个进程的开启和交流都会有开销（babel-loader消耗时间最久，所以使用thread-loader针对其进行优化）
{
  test: /\.js$/,
  exclude: /node_modules/,
  use: [
    /* 
      thread-loader会对其后面的loader（这里是babel-loader）开启多进程打包。 
      进程启动大概为600ms，进程通信也有开销。(启动的开销比较昂贵，不要滥用)
      只有工作消耗时间比较长，才需要多进程打包
    */
    {
      loader: &#39;thread-loader&#39;,
      options: {
        workers: 2 // 进程2个
      }
    },
    {
      loader: &#39;babel-loader&#39;,
      options: {
        presets: [
          [
            &#39;@babel/preset-env&#39;,
            {
              useBuiltIns: &#39;usage&#39;,
              corejs: { version: 3 },
              targets: {
                chrome: &#39;60&#39;,
                firefox: &#39;50&#39;
              }
            }
          ]
        ],
        // 开启babel缓存
        // 第二次构建时，会读取之前的缓存
        cacheDirectory: true
      }
    }
  ]
},

5.2.1.4 externals
externals：让某些库不打包，通过 cdn 引入
webpack.config.js 中配置：
externals: {
  // 拒绝jQuery被打包进来(通过cdn引入，速度会快一些)
  // 忽略的库名 -- npm包名
  jquery: &#39;jQuery&#39;
}

需要在 index.html 中通过 cdn 引入：
&amp;lt;script src=&amp;quot;https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

5.2.1.5 dll
dll：让某些库单独打包，后直接引入到 build 中。可以在 code split 分割出 node_modules 后再用 dll 更细的分割，优化代码运行的性能。
webpack.dll.js 配置：(将 jquery 单独打包)
/*
  node_modules的库会打包到一起，但是很多库的时候打包输出的js文件就太大了
  使用dll技术，对某些库（第三方库：jquery、react、vue...）进行单独打包
  当运行webpack时，默认查找webpack.config.js配置文件
  需求：需要运行webpack.dll.js文件
    --&amp;gt; webpack --config webpack.dll.js（运行这个指令表示以这个配置文件打包）
*/
const { resolve } = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;);

module.exports = {
  entry: {
    // 最终打包生成的[name] --&amp;gt; jquery
    // [&#39;jquery] --&amp;gt; 要打包的库是jquery
    jquery: [&#39;jquery&#39;]
  },
  output: {
    // 输出出口指定
    filename: &#39;[name].js&#39;, // name就是jquery
    path: resolve(__dirname, &#39;dll&#39;), // 打包到dll目录下
    library: &#39;[name]_[hash]&#39;, // 打包的库里面向外暴露出去的内容叫什么名字
  },
  plugins: [
    // 打包生成一个manifest.json --&amp;gt; 提供jquery的映射关系（告诉webpack：jquery之后不需要再打包和暴露内容的名称）
    new webpack.DllPlugin({
      name: &#39;[name]_[hash]&#39;, // 映射库的暴露的内容名称
      path: resolve(__dirname, &#39;dll/manifest.json&#39;) // 输出文件路径
    })
  ],
  mode: &#39;production&#39;
};

webpack.config.js 配置：(告诉 webpack 不需要再打包 jquery，并将之前打包好的 jquery 跟其他打包好的资源一同输出到 build 目录下)
// 引入插件
const webpack = require(&#39;webpack&#39;);
const AddAssetHtmlWebpackPlugin = require(&#39;add-asset-html-webpack-plugin&#39;);

// plugins中配置：
plugins: [
  new HtmlWebpackPlugin({
    template: &#39;./src/index.html&#39;
  }),
  // 告诉webpack哪些库不参与打包，同时使用时的名称也得变
  new webpack.DllReferencePlugin({
    manifest: resolve(__dirname, &#39;dll/manifest.json&#39;)
  }),
  // 将某个文件打包输出到build目录下，并在html中自动引入该资源
  new AddAssetHtmlWebpackPlugin({
    filepath: resolve(__dirname, &#39;dll/jquery.js&#39;)
  })
],

5.2.2 优化代码运行的性能
5.2.2.1 缓存
5.2.2.2 tree shaking（树摇）
tree shaking：去除无用代码
前提：1. 必须使用 ES6 模块化 2. 开启 production 环境 （这样就自动会把无用代码去掉）
作用：减少代码体积
在 package.json 中配置：
&amp;quot;sideEffects&amp;quot;: false 表示所有代码都没有副作用（都可以进行 tree shaking）
这样会导致的问题：可能会把 css / @babel/polyfill 文件干掉（副作用）
所以可以配置：&amp;quot;sideEffects&amp;quot;: [&amp;quot;*.css&amp;quot;, &amp;quot;*.less&amp;quot;] 不会对css/less文件tree shaking处理
5.2.2.3 code split（代码分割）
代码分割。将打包输出的一个大的 bundle.js 文件拆分成多个小文件，这样可以并行加载多个文件，比加载一个文件更快。
1.多入口拆分
entry: {
    // 多入口：有一个入口，最终输出就有一个bundle
    index: &#39;./src/js/index.js&#39;,
    test: &#39;./src/js/test.js&#39;
  },
  output: {
    // [name]：取文件名
    filename: &#39;js/[name].[contenthash:10].js&#39;,
    path: resolve(__dirname, &#39;build&#39;)
  },

2.optimization：
optimization: {
    splitChunks: {
      chunks: &#39;all&#39;
    }
  },


将 node_modules 中的代码单独打包（大小超过30kb）
自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk(比如两个模块中都引入了jquery会被打包成单独的文件)（大小超过30kb）

3.import 动态导入语法：
/*
  通过js代码，让某个文件被单独打包成一个chunk
  import动态导入语法：能将某个文件单独打包(test文件不会和index打包在同一个文件而是单独打包)
  webpackChunkName:指定test单独打包后文件的名字
*/
import(/* webpackChunkName: &#39;test&#39; */&#39;./test&#39;)
  .then(({ mul, count }) =&amp;gt; {
    // 文件加载成功~
    // eslint-disable-next-line
    console.log(mul(2, 5));
  })
  .catch(() =&amp;gt; {
    // eslint-disable-next-line
    console.log(&#39;文件加载失败~&#39;);
  });

5.2.2.4 lazy loading（懒加载/预加载）
1.懒加载：当文件需要使用时才加载（需要代码分割）。但是如果资源较大，加载时间就会较长，有延迟。
2.正常加载：可以认为是并行加载（同一时间加载多个文件）没有先后顺序，先加载了不需要的资源就会浪费时间。
3.预加载 prefetch（兼容性很差）：会在使用之前，提前加载。等其他资源加载完毕，浏览器空闲了，再偷偷加载这个资源。这样在使用时已经加载好了，速度很快。所以在懒加载的基础上加上预加载会更好。
代码：
document.getElementById(&#39;btn&#39;).onclick = function() {
  // 将import的内容放在异步回调函数中使用，点击按钮，test.js才会被加载(不会重复加载)
  // webpackPrefetch: true表示开启预加载
  import(/* webpackChunkName: &#39;test&#39;, webpackPrefetch: true */&#39;./test&#39;).then(({ mul }) =&amp;gt; {
    console.log(mul(4, 5));
  });
  import(&#39;./test&#39;).then(({ mul }) =&amp;gt; {
    console.log(mul(2, 5))
  })
};

5.2.2.5 pwa（离线可访问技术）
pwa：离线可访问技术（渐进式网络开发应用程序），使用 serviceworker 和 workbox 技术。优点是离线也能访问，缺点是兼容性差。
webpack.config.js 中配置：
const WorkboxWebpackPlugin = require(&#39;workbox-webpack-plugin&#39;); // 引入插件

// plugins中加入：
new WorkboxWebpackPlugin.GenerateSW({
  /*
    1. 帮助serviceworker快速启动
    2. 删除旧的 serviceworker

    生成一个 serviceworker 配置文件
  */
  clientsClaim: true,
  skipWaiting: true
})

index.js 中还需要写一段代码来激活它的使用：
/*
  1. eslint不认识 window、navigator全局变量
    解决：需要修改package.json中eslintConfig配置
    &amp;quot;env&amp;quot;: {
      &amp;quot;browser&amp;quot;: true // 支持浏览器端全局变量
    }
  2. sw代码必须运行在服务器上
    --&amp;gt; nodejs
    或--&amp;gt;
      npm i serve -g
      serve -s build 启动服务器，将打包输出的build目录下所有资源作为静态资源暴露出去
*/
if (&#39;serviceWorker&#39; in navigator) { // 处理兼容性问题
  window.addEventListener(&#39;load&#39;, () =&amp;gt; {
    navigator.serviceWorker
      .register(&#39;/service-worker.js&#39;) // 注册serviceWorker
      .then(() =&amp;gt; {
        console.log(&#39;sw注册成功了~&#39;);
      })
      .catch(() =&amp;gt; {
        console.log(&#39;sw注册失败了~&#39;);
      });
  });
}

六、Webpack 配置详情
6.1 entry
entry: 入口起点


string --&amp;gt; &#39;./src/index.js&#39;，单入口
打包形成一个 chunk。 输出一个 bundle 文件。此时 chunk 的名称默认是 main


array --&amp;gt; [&#39;./src/index.js&#39;, &#39;./src/add.js&#39;]，多入口
所有入口文件最终只会形成一个 chunk，输出出去只有一个 bundle 文件。
（一般只用在 HMR 功能中让 html 热更新生效）


object，多入口
有几个入口文件就形成几个 chunk，输出几个 bundle 文件，此时 chunk 的名称是 key 值


--&amp;gt; 特殊用法：
entry: {
  // 最终只会形成一个chunk, 输出出去只有一个bundle文件。
  index: [&#39;./src/index.js&#39;, &#39;./src/count.js&#39;], 
  // 形成一个chunk，输出一个bundle文件。
  add: &#39;./src/add.js&#39;
}

6.2 output
output: {
  // 文件名称（指定名称+目录）
  filename: &#39;js/[name].js&#39;,
  // 输出文件目录（将来所有资源输出的公共目录）
  path: resolve(__dirname, &#39;build&#39;),
  // 所有资源引入公共路径前缀 --&amp;gt; &#39;imgs/a.jpg&#39; --&amp;gt; &#39;/imgs/a.jpg&#39;
  publicPath: &#39;/&#39;,
  chunkFilename: &#39;js/[name]_chunk.js&#39;, // 指定非入口chunk的名称
  library: &#39;[name]&#39;, // 打包整个库后向外暴露的变量名
  libraryTarget: &#39;window&#39; // 变量名添加到哪个上 browser：window
  // libraryTarget: &#39;global&#39; // node：global
  // libraryTarget: &#39;commonjs&#39; // conmmonjs模块 exports
},

6.3 module
module: {
  rules: [
    // loader的配置
    {
      test: /\.css$/,
      // 多个loader用use
      use: [&#39;style-loader&#39;, &#39;css-loader&#39;]
    },
    {
      test: /\.js$/,
      // 排除node_modules下的js文件
      exclude: /node_modules/,
      // 只检查src下的js文件
      include: resolve(__dirname, &#39;src&#39;),
      enforce: &#39;pre&#39;, // 优先执行
      // enforce: &#39;post&#39;, // 延后执行
      // 单个loader用loader
      loader: &#39;eslint-loader&#39;,
      options: {} // 指定配置选项
    },
    {
      // 以下配置只会生效一个
      oneOf: []
    }
  ]
},

6.4 resolve
// 解析模块的规则
resolve: {
  // 配置解析模块路径别名: 优点：当目录层级很复杂时，简写路径；缺点：路径不会提示
  alias: {
    $css: resolve(__dirname, &#39;src/css&#39;)
  },
  // 配置省略文件路径的后缀名（引入时就可以不写文件后缀名了）
  extensions: [&#39;.js&#39;, &#39;.json&#39;, &#39;.jsx&#39;, &#39;.css&#39;],
  // 告诉 webpack 解析模块应该去找哪个目录
  modules: [resolve(__dirname, &#39;../../node_modules&#39;), &#39;node_modules&#39;]
}

这样配置后，引入文件就可以这样简写：import &#39;$css/index&#39;;
6.5 dev server
devServer: {
  // 运行代码所在的目录
  contentBase: resolve(__dirname, &#39;build&#39;),
  // 监视contentBase目录下的所有文件，一旦文件变化就会reload
  watchContentBase: true,
  watchOptions: {
    // 忽略文件
    ignored: /node_modules/
  },
  // 启动gzip压缩
  compress: true,
  // 端口号
  port: 5000,
  // 域名
  host: &#39;localhost&#39;,
  // 自动打开浏览器
  open: true,
  // 开启HMR功能
  hot: true,
  // 不要显示启动服务器日志信息
  clientLogLevel: &#39;none&#39;,
  // 除了一些基本信息外，其他内容都不要显示
  quiet: true,
  // 如果出错了，不要全屏提示
  overlay: false,
  // 服务器代理，--&amp;gt; 解决开发环境跨域问题
  proxy: {
    // 一旦devServer(5000)服务器接收到/api/xxx的请求，就会把请求转发到另外一个服务器3000
    &#39;/api&#39;: {
      target: &#39;http://localhost:3000&#39;,
      // 发送请求时，请求路径重写：将/api/xxx --&amp;gt; /xxx （去掉/api）
      pathRewrite: {
        &#39;^/api&#39;: &#39;&#39;
      }
    }
  }
}

其中，跨域问题：同源策略中不同的协议、端口号、域名就会产生跨域。
正常的浏览器和服务器之间有跨域，但是服务器之间没有跨域。代码通过代理服务器运行，所以浏览器和代理服务器之间没有跨域，浏览器把请求发送到代理服务器上，代理服务器替你转发到另外一个服务器上，服务器之间没有跨域，所以请求成功。代理服务器再把接收到的响应响应给浏览器。这样就解决开发环境下的跨域问题。
6.6 optimization
contenthash 缓存会导致一个问题：修改 a 文件导致 b 文件 contenthash 变化。
因为在 index.js 中引入 a.js，打包后 index.js 中记录了 a.js 的 hash 值，而 a.js 改变，其重新打包后的 hash 改变，导致 index.js 文件内容中记录的 a.js 的 hash 也改变，从而重新打包后 index.js 的 hash 值也会变，这样就会使缓存失效。（改变的是a.js文件但是 index.js 文件的 hash 值也改变了）
解决办法：runtimeChunk --&amp;gt; 将当前模块记录其他模块的 hash 单独打包为一个文件 runtime，这样 a.js 的 hash 改变只会影响 runtime 文件，不会影响到 index.js 文件
output: {
  filename: &#39;js/[name].[contenthash:10].js&#39;,
  path: resolve(__dirname, &#39;build&#39;),
  chunkFilename: &#39;js/[name].[contenthash:10]_chunk.js&#39; // 指定非入口文件的其他chunk的名字加_chunk
},
optimization: {
  splitChunks: {
    chunks: &#39;all&#39;,
    /* 以下都是splitChunks默认配置，可以不写
    miniSize: 30 * 1024, // 分割的chunk最小为30kb（大于30kb的才分割）
    maxSize: 0, // 最大没有限制
    minChunks: 1, // 要提取的chunk最少被引用1次
    maxAsyncRequests: 5, // 按需加载时并行加载的文件的最大数量为5
    maxInitialRequests: 3, // 入口js文件最大并行请求数量
    automaticNameDelimiter: &#39;~&#39;, // 名称连接符
    name: true, // 可以使用命名规则
    cacheGroups: { // 分割chunk的组
      vendors: {
        // node_modules中的文件会被打包到vendors组的chunk中，--&amp;gt; vendors~xxx.js
        // 满足上面的公共规则，大小超过30kb、至少被引用一次
        test: /[\\/]node_modules[\\/]/,
        // 优先级
        priority: -10
      },
      default: {
        // 要提取的chunk最少被引用2次
        minChunks: 2,
        prority: -20,
        // 如果当前要打包的模块和之前已经被提取的模块是同一个，就会复用，而不是重新打包
        reuseExistingChunk: true
      }
    } */
  },
  // 将index.js记录的a.js的hash值单独打包到runtime文件中
  runtimeChunk: {
    name: entrypoint =&amp;gt; `runtime-${entrypoint.name}`
  },
  minimizer: [
    // 配置生产环境的压缩方案：js/css
    new TerserWebpackPlugin({
      // 开启缓存
      cache: true,
      // 开启多进程打包
      parallel: true,
      // 启用sourceMap(否则会被压缩掉)
      sourceMap: true
    })
  ]
}

七、Webpack5 介绍和使用
此版本重点关注以下内容:

通过持久缓存提高构建性能.
使用更好的算法和默认值来改善长期缓存.
通过更好的树摇和代码生成来改善捆绑包大小.
清除处于怪异状态的内部结构，同时在 v4 中实现功能而不引入任何重大更改.
通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间地使用 v5.

下载
npm i webpack@next webpack-cli -D
自动删除 Node.js Polyfills
早期，webpack 的目标是允许在浏览器中运行大多数 node.js 模块，但是模块格局发生了变化，许多模块用途现在主要是为前端目的而编写的。webpack &amp;lt;= 4 附带了许多 node.js 核心模块的 polyfill，一旦模块使用任何核心模块（即 crypto 模块），这些模块就会自动应用。
尽管这使使用为 node.js 编写的模块变得容易，但它会将这些巨大的 polyfill 添加到包中。在许多情况下，这些 polyfill 是不必要的。
webpack 5 会自动停止填充这些核心模块，并专注于与前端兼容的模块。
迁移：

尽可能尝试使用与前端兼容的模块。
可以为 node.js 核心模块手动添加一个 polyfill。错误消息将提示如何实现该目标。

Chunk 和模块 ID
添加了用于长期缓存的新算法。在生产模式下默认情况下启用这些功能。
chunkIds: &amp;quot;deterministic&amp;quot;, moduleIds: &amp;quot;deterministic&amp;quot;

Chunk ID
你可以不用使用 import(/* webpackChunkName: &amp;quot;name&amp;quot; */ &amp;quot;module&amp;quot;) 在开发环境来为 chunk 命名，生产环境还是有必要的
webpack 内部有 chunk 命名规则，不再是以 id(0, 1, 2)命名了
Tree Shaking

webpack 现在能够处理对嵌套模块的 tree shaking

// inner.js
export const a = 1;
export const b = 2;

// module.js
import * as inner from &#39;./inner&#39;;
export { inner };

// user.js
import * as module from &#39;./module&#39;;
console.log(module.inner.a);

在生产环境中, inner 模块暴露的 b 会被删除

webpack 现在能够多个模块之前的关系

import { something } from &#39;./something&#39;;

function usingSomething() {
  return something;
}

export function test() {
  return usingSomething();
}

当设置了&amp;quot;sideEffects&amp;quot;: false时，一旦发现test方法没有使用，不但删除test，还会删除&amp;quot;./something&amp;quot;

webpack 现在能处理对 Commonjs 的 tree shaking

Output
webpack 4 默认只能输出 ES5 代码
webpack 5 开始新增一个属性 output.ecmaVersion, 可以生成 ES5 和 ES6 / ES2015 代码.
如：output.ecmaVersion: 2015
SplitChunk
// webpack4
minSize: 30000;
// webpack5
minSize: {
  javascript: 30000,
  style: 50000,
}

Caching
// 配置缓存
cache: {
  // 磁盘存储
  type: &amp;quot;filesystem&amp;quot;,
  buildDependencies: {
    // 当配置修改时，缓存失效
    config: [__filename]
  }
}

缓存将存储到 node_modules/.cache/webpack
监视输出文件
之前 webpack 总是在第一次构建时输出全部文件，但是监视重新构建时会只更新修改的文件。
此次更新在第一次构建时会找到输出文件看是否有变化，从而决定要不要输出全部文件。
默认值

entry: &amp;quot;./src/index.js
output.path: path.resolve(__dirname, &amp;quot;dist&amp;quot;)
output.filename: &amp;quot;[name].js&amp;quot;

更多内容
github

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://wmyme.github.io/post/hello-gridea/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://wmyme.github.io//images/avatar.png?v=1628740403686)">
        </div>
        <h1 class="id_card-title">
            Gridea
        </h1>
        <h2 class="id_card-description">
            温故而知新
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  <span id="sitetime"></span>
<script language=javascript>
    function siteTime(){
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth()+1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        var t1 = Date.UTC(2020,8,11,00,00,00); //北京时间2016-12-1 00:00:00
        var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
        var diff = t2-t1;
        var diffYears = Math.floor(diff/years);
        var diffDays = Math.floor((diff/days)-diffYears*365);
        var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
        var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
        var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
        document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+"年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
    }
    siteTime();
</script> | 
  <a class="rss" href="https://wmyme.github.io//atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>